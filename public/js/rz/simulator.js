//simulator of Rz processor
//recieve machine code as input
//machine code is generated by assembler in atx.js

var timer0range, timer1range;

var memDisplayAddress = 0;

var MAXMEM = 20000;		// memory max
var DEL	= 100;			// interrupt interval (inst)
var INTVEC = 1000;		// int vec location
var STRSEG = 9000; 		//string segment
var MAXSIM = 10000;		// max sim clock
var RETV = 28;			// return value register
var SPTR = 29;			// stack pointer
var HEAP = 10000;		// heap for malloc

var ip;
var Ir, Pc, RetAds;
var markLoc = -1;
var runflag, saveflaf, cpuflag;
var heapfree = HEAP;

var display = true, savePc;
var enableSimDebug = false;
var markLoc = -1;
var trapString = "";
//var T;
var step, ninst, clock; 
var end = false;

var intflag, intnum;
var intmask = [false, false, false, false];
var intrq = [false, false, false, false];

var M = new Array();
var R = Array(32).fill(0);
var opCode = [];

var initOpCode = [["NOP", 0], ["LDA", 1], ["LDD", 2], ["STA", 3],
				["STD", 4], ["MVI", 5], ["JMP", 6], ["JAL", 7],
				["JT", 8], ["JF", 9], ["ADDI", 10], ["SUBI", 11],
				["MULI", 12], ["DIVI", 13], ["ANDI", 14], ["ORI", 15],
				["XORI", 16], ["EQI", 17], ["NEI", 18], ["LTI", 19],
				["LEI", 20], ["GTI", 21], ["GEI", 22], ["SHLI", 23],
				["SHRI", 24], ["MODI", 25], ["XOP", 31],
				
				//	xop
				["ADD", 0], ["SUB", 1], ["MUL", 2], ["DIV", 3],
				["AND", 4], ["OR", 5], ["XOR", 6], ["EQ", 7],
				["NE", 8], ["LT", 9], ["LE", 10], ["GT", 11],
				["GE", 12], ["SHL", 13], ["SHR", 14], ["MOD", 15],
				["MOV", 16], ["LDX", 17], ["STX", 18], ["RET", 19],
				["TRAP", 20], ["PUSH", 21], ["POP", 22], ["NOT", 23],
				["INT", 24], ["RETI", 25], ["PUSHM", 26], ["POPM", 27],
				["XCH", 28],

				["RETV", 28], ["SPTR", 29]
				];

function initOp(){
	for(var i = 0; i < initOpCode.length; i++){
		opCode[initOpCode[i][0]] = initOpCode[i][1];
	}
	
}

function simlog(string){
	if(enableSimDebug)
		printOutput("<br>" + string + "<br>");
	console.log(string);
}

function initcpu(){
	display = true;
	clock = 0;
	ninst = 0;
	step = 1;
	Pc = 0;
	runflag = true;
	cpuflag = true;
	intflag = true;
	intmask[0] = 1;
	intmask[1] = 0;
	intmask[2] = 0;
	intmask[3] = 0;
	var i;
	M = new Array();
	for(i = 0; i < 32; i++){
		R[i] = 0;
	}
	initOpCode = [["NOP", 0], ["LDA", 1], ["LDD", 2], ["STA", 3],
		["STD", 4], ["MVI", 5], ["JMP", 6], ["JAL", 7],
		["JT", 8], ["JF", 9], ["ADDI", 10], ["SUBI", 11],
		["MULI", 12], ["DIVI", 13], ["ANDI", 14], ["ORI", 15],
		["XORI", 16], ["EQI", 17], ["NEI", 18], ["LTI", 19],
		["LEI", 20], ["GTI", 21], ["GEI", 22], ["SHLI", 23],
		["SHRI", 24], ["MODI", 25], ["XOP", 31],
		
		//	xop
		["ADD", 0], ["SUB", 1], ["MUL", 2], ["DIV", 3],
		["AND", 4], ["OR", 5], ["XOR", 6], ["EQ", 7],
		["NE", 8], ["LT", 9], ["LE", 10], ["GT", 11],
		["GE", 12], ["SHL", 13], ["SHR", 14], ["MOD", 15],
		["MOV", 16], ["LDX", 17], ["STX", 18], ["RET", 19],
		["TRAP", 20], ["PUSH", 21], ["POP", 22], ["NOT", 23],
		["INT", 24], ["RETI", 25], ["PUSHM", 26], ["POPM", 27],
		["XCH", 28],

		["RETV", 28], ["SPTR", 29]
		];
}

function dumpreg(){
	
	printOutput('<span class="regDisplay">');
	var i;
	for(i=0; i<32; i++){
		if(i == markLoc)
			printOutput("<b>r" + i.toString() + ":" + R[i].toString() + "</b> ");
		else
			printOutput("r" + i.toString() + ":" + R[i].toString() + " ");
	}
	printOutput("</span><br>");
}

function memJump(){
	memDisplayAddress = document.getElementById("memAddress").value;
	if(memDisplayAddress < 0)
		memDisplayAddress = 0;
	updateMemDisplay();
}

function updateMemDisplay(){
	var offset = memDisplayAddress;
    for(var i = offset; i < (offset+100); i++){
    	
    	var str = "";
    	
    	str += "m";
    	str += i.toString();
    	str += " : ";
    	
    	if(M[i] != 'undefined'){
	    	str += (M[i] >> 27) & 0x01F;
	    	str += ' ';
	    	str += (M[i] >> 22) & 0x01F;
	    	str += ' ';
	    	str += (M[i] >> 17) & 0x01F;
	    	str += ' ';
	    	str += (M[i] >> 12) & 0x01F;
	    	str += ' ';
	    	str += M[i] & 0x0FFF;
    	}
    	else{
    		str += "-"
    	}
    	
    	var ref = "m";
    	ref += (i-offset).toString();
    	document.getElementById(ref).innerHTML = str;
    	
    } 
//    claerTxtArea2();
//    printTxtArea2(str);
}

function printSimTxtArea(string){
	if(display)
		printOutput(string);
}

function pr(s){
	printOutput("<span class='opDisplay'>" + s + "</span><span class='paraDisplay'></span>");
}
function pr3R(s){
	printOutput("<span class='opDisplay'>" + s + "</span><span class='paraDisplay'>r" + IRr1() + " r" +IRr2() + " r" + IRr3() + "</span>");
}
function prI(s) {
	printOutput("<span class='opDisplay'>" + s + "</span><span class='paraDisplay'>r" + IRr1() + " r" +IRr2() + " #" + IRdisp() + "</span>");
}
function prA(s) {
	printOutput("<span class='opDisplay'>" + s + "</span><span class='paraDisplay'>r" + IRr1() + " " + IRads() + "</span>");
}
function pr2R(s){
	printOutput("<span class='opDisplay'>" + s + "</span><span class='paraDisplay'>r" + IRr1() + " r" + IRr2() + "</span>");
}
function pr1R(s){
	printOutput("<span class='opDisplay'>" + s + "</span><span class='paraDisplay'>r" + IRr1() + "</span>");
}

function disassem(){
	switch(IRop()){
		case opCode["NOP"]	:	pr("nop"); break;
		case opCode["LDA"]	:	prA("ld"); break;
		case opCode["LDD"]	:	printOutput("<span class='opDisplay'>ld</span><span class='paraDisplay'>r" + IRr1() + " @" + IRdisp() + " r" + IRr2() + "</span>"); break;
		case opCode["STA"]	:	prA("st"); break;
		case opCode["STD"]	:	printOutput("<span class='opDisplay'>st</span><span class='paraDisplay'>r" + IRr1() + " @" + IRdisp() + " r" + IRr2() + "</span>"); break;
		case opCode["JMP"]	:	printOutput("<span class='opDisplay'>jmp</span><span class='paraDisplay'>" + IRads() + "</span>"); break;
		case opCode["JAL"]	:	prA("jal"); break;
		case opCode["JT"]	:	prA("jt"); break;
		case opCode["JF"]	:	prA("jf"); break;
		case opCode["MVI"]	:	printOutput("<span class='opDisplay'>mov</span><span class='paraDisplay'>r" + IRr1() + " #" + signx2(IRads()) + "</span>"); break;
		case opCode["ADDI"]	:	prI("add"); break;
		case opCode["SUBI"]	:	prI("sub"); break;
		case opCode["MULI"]	:	prI("mul"); break;
		case opCode["DIVI"]	:	prI("div"); break;
		case opCode["ANDI"]	:	prI("and"); break;
		case opCode["ORI"]	:	prI("or"); break;
		case opCode["XORI"]	:	prI("xor"); break;
		case opCode["EQI"]	:	prI("eq"); break;
		case opCode["NEI"]	:	prI("ne"); break;
		case opCode["LTI"]	:	prI("lt"); break;
		case opCode["LEI"]	:	prI("le"); break;
		case opCode["GTI"]	:	prI("gt"); break;
		case opCode["GEI"]	:	prI("ge"); break;
		case opCode["SHLI"]	:	prI("shl"); break;
		case opCode["SHRI"]	:	prI("shr"); break;
		case opCode["MODI"]	:	prI("mod"); break;
		case opCode["XOP"]	:	
			switch(IRxop()){
				case opCode["ADD"]	:	pr3R("add"); break;
				case opCode["SUB"]	:	pr3R("sub"); break;
				case opCode["MUL"]	:	pr3R("mul"); break;
				case opCode["DIV"]	:	pr3R("div"); break;
				case opCode["AND"]	:	pr3R("and"); break;
				case opCode["OR"]	:	pr3R("or"); break;
				case opCode["XOR"]	:	pr3R("xor"); break;
				case opCode["EQ"]	:	pr3R("eq"); break;
				case opCode["NE"]	:	pr3R("ne"); break;
				case opCode["LT"]	:	pr3R("lt"); break;
				case opCode["LE"]	:	pr3R("le"); break;
				case opCode["GT"]	:	pr3R("gt"); break;
				case opCode["GE"]	:	pr3R("ge"); break;
				case opCode["SHL"]	:	pr3R("shl"); break;
				case opCode["SHR"]	:	pr3R("shr"); break;
				case opCode["MOD"]	:	pr3R("mod"); break;
				case opCode["MOV"]	:	pr2R("mov"); break;
				case opCode["PUSH"]	:	pr2R("push"); break;
				case opCode["POP"]	:	pr2R("pop"); break;
				case opCode["LDX"]	:	printOutput("<span class='opDisplay'>ld</span><span class='paraDisplay'>r" + IRr1() + " +" + IRr2() + " r" + IRr3() + "</span>"); break;
				case opCode["STX"]	:	printOutput("<span class='opDisplay'>st</span><span class='paraDisplay'>r" + IRr1() + " +" + IRr2() + " r" + IRr3() + "</span>"); break;
				case opCode["RET"]	:	pr1R("ret"); break;
				case opCode["TRAP"]	:	printOutput("<span class='opDisplay'>trap</span><span class='paraDisplay'>r" + IRr1() + " #" + IRr2() + "</span>"); break;
				case opCode["NOT"]	:	pr2R("not"); break;
				case opCode["INT"]	:	printOutput("<span class='opDisplay'>int</span><span class='paraDisplay'>#" + IRr1() + "</span>"); break;
				case opCode["RETI"]	:	pr("reti"); break;
				case opCode["PUSHM"]	:	pr1R("pushm"); break;
				case opCode["POPM"]	:	pr1R("popm"); break;
				case opCode["XCH"]	:	pr1R("xch"); break;
				
			
				default : pr("error1"); break;
			}
			break;
		
	
		default: pr("error1"); break;
	}
}

function runUntilStop(){
	display = false;
	while(runflag)
		runoneclock();
	if(!end){
		display = true;
		//updateMemDisplay();
		printOutput("");
		//printOutput("Finished at step " + (step-1).toString());
		//dumpreg();
		end = true;
	}
}

function signx2(d){	// sign bit 21 extended
	if( d & 0x0200000 ) return d | 0xFFC00000;
	return d;
}

function signx(d){		// sign bit 16 extended
	if( d & 0x010000 ) return d | 0xFFFE0000;
	return d;
}

function IRop()  { return((Ir >> 27) & 0x01F);} // bit 31..27
function IRr1()  { return((Ir >> 22) & 0x01F);} // bit 26..22
function IRads() { return( Ir & 0x003FFFFF  );} // bit 21..0
function IRr2()  { return((Ir >> 17) & 0x01F);} // bit 21..17
function IRr3()  { return((Ir >> 12) & 0x01F);} // bit 16..12
function IRxop() { return( Ir & 0x0FFF      );} // bit 11..0
function IRdisp(){ return(signx(Ir & 0x01FFFF));} // bit 16..0

function trap(reg, num){
	var n, i, x, y;
	switch(num){
		case 0: 		//stop
			runflag = false;
			trapString = "stop, clock " + clock + ", execute " + ninst + " instructions";
			break;
		case 1: 		//print integer
			trapString = R[reg] + "";
			break;
		case 2: 		//printc
			trapString = String.fromCharCode(97 + R[reg]);
			break;
		case 3: 		//print string
			i = 0;
			x = M[STRSEG + i];
			var buf = "";
			while(x != 0){
				buf += String.fromCharCode(97 + x);
				i++;
				x = M[STRSEG + i];
			}
			trapString = buf;
			break;	
		case 4:			//iput (return string)
			var buf = "string";
			i = 0;
			while(i < buff.length){
				buf += String.fromCharCode(97 + x);
				M[STRSEG + i] = buff.charAt(i);
				i++;
			}
			M[STRSEG + i] = 0; 		// terminate string
			R[RETV] = STRSEG;		// return pointer to string
			break;	
		case 15: 		//disable int
			n = R[reg];
			intmask[n] = false;
			break;
		case 16: 			// enable int
			n = R[reg];
			intmask[n] = true;
			break;
		case 17: cpuflag = false; break;	// put cpu to sleep
		case 19:			// malloc
			R[RETV] = heapfree;
			heapfree += R[reg];
			if( heapfree > MAXMEM )
				simlog("malloc: out of memory");
			break;
	
	}
	
}

function interrupt(n){
	if( n > 3 )
		simlog("unknown interrupt");
	intnum = n;
	RetAds = Pc;		// save pc
	Pc = M[INTVEC+n];
	cpuflag = true; 		// wake up sleepy cpu
	intflag = false;		// master disable interrupt
	intrq[n] = false;		// clear int request
}

function checkinterrupt(){
	if( intflag ){
		if( intmask[0] && intrq[0] ) interrupt(0);
		else if( intmask[1] && intrq[1] ) interrupt(1);
		else if( intmask[2] && intrq[2] ) interrupt(2);
		else if( intmask[3] && intrq[3] ) interrupt(3);
	}
}

function runoneclock(){
	clock++;
	if( runflag && cpuflag ){
		run();
	}
	checkinterrupt();
}

//execute one instruction
function run(){
	
	if(!runflag)
		return;
	
	var ads, d, r1, r2, r3, i;
	
	printOutput("Clock " + clock);
	printOutput("<span class='pcDisplay'>PC " + Pc.toString() + "</span>");

	savePc = Pc;
	Ir = M[Pc];
	Pc++;
	ads = IRads();
	d = IRdisp();
	r1 = IRr1();
	r2 = IRr2(); 
	r3 = IRr3();
	ninst++;
	
	markLoc = -1;
	trapString = "";
	
	switch(IRop()){
		case opCode["NOP"]:		break;
		case opCode["LDA"]:		R[r1] = M[ads];			markLoc = r1; break;
		case opCode["LDD"]:		R[r1] = M[R[r2]+d];		markLoc = r1; break;
		case opCode["STA"]:		M[ads] = R[r1];			break;
		case opCode["STD"]:		M[R[r2]+d] = R[r1];		break;
		case opCode["MVI"]:		R[r1] = signx2(ads);	markLoc = r1; break;
		case opCode["JMP"]:		Pc = ads;				break;
		case opCode["JAL"]:		R[r1] = Pc; Pc = ads;	break;
		case opCode["JT"]:		if(R[r1] != 0) Pc = ads;	break;
		case opCode["JF"]:		if(R[r1] == 0) Pc = ads;	break;
		case opCode["ADDI"]:	R[r1] = R[r2] + d;		markLoc = r1; break;
		case opCode["SUBI"]:	R[r1] = R[r2] - d;		markLoc = r1; break;
		case opCode["MULI"]:	R[r1] = R[r2] * d;		markLoc = r1; break;
		case opCode["DIVI"]:	R[r1] = R[r2] / d;		markLoc = r1; break;
		case opCode["ANDI"]:	R[r1] = R[r2] & d;		markLoc = r1; break;
		case opCode["ORI"]:		R[r1] = R[r2] | d;		markLoc = r1; break;
		case opCode["XORI"]:	R[r1] = R[r2] ^ d;		markLoc = r1; break;
		case opCode["EQI"]:		R[r1] = R[r2] == d;		markLoc = r1; break;
		case opCode["NEI"]:		R[r1] = R[r2] != d;		markLoc = r1; break;
		case opCode["LTI"]:		R[r1] = R[r2] <  d;		markLoc = r1; break;
		case opCode["LEI"]:		R[r1] = R[r2] <= d;		markLoc = r1; break;
		case opCode["GTI"]:		R[r1] = R[r2] >  d;		markLoc = r1; break;
		case opCode["GEI"]:		R[r1] = R[r2] >= d;		markLoc = r1; break;
		case opCode["SHLI"]:	R[r1] = R[r2] << d;		markLoc = r1; break;
		case opCode["SHRI"]:	R[r1] = R[r2] >> d;		markLoc = r1; break;
		case opCode["MODI"]:	R[r1] = R[r2] %  d;		markLoc = r1; break;
		case opCode["XOP"]:	
			switch(IRxop()){
				case opCode["ADD"]:		R[r1] = R[r2] + R[r3];	markLoc = r1; break;
				case opCode["SUB"]:		R[r1] = R[r2] - R[r3];	markLoc = r1; break;
				case opCode["MUL"]:		R[r1] = R[r2] * R[r3];	markLoc = r1; break;
				case opCode["DIV"]:		R[r1] = R[r2] / R[r3];	markLoc = r1; break;
				case opCode["AND"]:		R[r1] = R[r2] & R[r3];	markLoc = r1; break;
				case opCode["OR"]:		R[r1] = R[r2] | R[r3];	markLoc = r1; break;
				case opCode["XOR"]:		R[r1] = R[r2] ^ R[r3];	markLoc = r1; break;
				case opCode["EQ"]:		R[r1] = R[r2] == R[r3];	markLoc = r1; break;
				case opCode["NE"]:		R[r1] = R[r2] != R[r3];	markLoc = r1; break;
				case opCode["LT"]:		R[r1] = R[r2] <  R[r3];	markLoc = r1; break;
				case opCode["LE"]:		R[r1] = R[r2] <= R[r3];	markLoc = r1; break;
				case opCode["GT"]:		R[r1] = R[r2] >  R[r3];	markLoc = r1; break;
				case opCode["GE"]:		R[r1] = R[r2] >= R[r3];	markLoc = r1; break;
				case opCode["SHL"]:		R[r1] = R[r2] << R[r3];	markLoc = r1; break;
				case opCode["SHR"]:		R[r1] = R[r2] >> R[r3];	markLoc = r1; break;
				case opCode["MOD"]:		R[r1] = R[r2] %  R[r3];	markLoc = r1; break;
				case opCode["MOV"]:		R[r1] = R[r2];			markLoc = r1; break;
				case opCode["LDX"]:		R[r1] = M[R[r2] + R[r3]];	markLoc = r1; break;
				case opCode["STX"]:		M[R[r2] + R[r3]] = R[r1];	break;
				case opCode["RET"]:		Pc = R[r1];	break;
				case opCode["TRAP"]:	trap(r1,r2);	break;
				case opCode["PUSH"]:	
					R[r1]++;
					M[R[r1]] = R[r2];
					break;
				case opCode["POP"]:		
					R[r2] = M[R[r1]];
					R[r1]--;	
					markLoc = r2; 
					break;
				case opCode["NOT"]:		R[r1] = (R[r2] == 0) ? ~0 : 0;	markLoc = r1; break;
				case opCode["INT"]:		interrupt(r1);	break;
				case opCode["RETI"]:	
					Pc = RetAds;
					intflag = true;	
					break;
				case opCode["PUSHM"]:	
					for(i = 0; i < 16; i++){
						R[r1]++;
						M[R[r1]] = R[i];
					}	
					break;
				case opCode["POPM"]:	
					for(i = 15; i >= 0; i--){
						R[i] = M[R[r1]];
						R[r1]--;
					}
					break;
				case opCode["XCH"]:		
					d = RetAds;
					RetAds = R[r1];
					R[r1] = d;	
					break;
				
				default:	error("undefined xop");	break;
			}
			break;

		default:	error("undefined op");	break;
	}

	disassem();
	dumpreg();
	printOutput("<br>");
	if(trapString != ""){
		printOutput(trapString + "<br>");
	}
		
	step++;
}


function load(){
	
	runflag = true;
	display = true;
	end = false;
	
	initcpu();
	initOp();
	
	var sInput = plainTextMC.value;
	var sOutput = "";

	var lines = sInput.split('\n');

	var cnt, a1, a2, a3, a4, a5;
	ip = 0;
	
	for(var i = 0; i < lines.length; i++){
	    //code here using lines[i] which will give you each line
		
	    var EoF = false;
	    
	    tokens = lines[i].split(' ');

	    switch(tokens[0]) {
		    case 'a':
		        ip = parseInt(tokens[1]);
		        break;
		    case 'L':
		        a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]); a3 = parseInt(tokens[3]);
		        M[ip] = a1<<27 | a2<<22 | (a3&0x3FFFFF);
		        ip++;
		        break;
		    case 'D':
		    	a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]); a3 = parseInt(tokens[3]); a4 = parseInt(tokens[4]);
		    	M[ip] = a1<<27 | a2<<22 | a3<<17 | (a4&0x1FFFF);
				ip++;
				break;
		    case 'X':
		    	a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]); a3 = parseInt(tokens[3]); a4 = parseInt(tokens[4]); a5 = parseInt(tokens[5]);
		    	M[ip] = a1<<27 | a2<<22 | a3<<17 | a4<<12 | (a5&0x0FFF);
				ip++;
				break;
		    case 'w' :
			    M[ ip] = parseInt(tokens[1]);
			    ip++;
				break;
		    case 'e':
			    EoF = true;
			    break;
		    default:
		        break;
		}

	    if(EoF){
		    break;
	    }
	}
	
	clearOutput();
	
	printOutput("load program, last address " + ip.toString() + "<br>");
	
	updateMemDisplay()
	
}


function viewMem() {
    var myWindow = window.open("Memory", "Memory", "width=700,height=500,directories=no,titlebar=no");
    var str = "";
    for(var i=0; i<100; i++){
    	str += "m";
    	str += i.toString();
    	str += " : ";
    	str += (M[i] >> 27) & 0x01F;
    	str += ' ';
    	str += (M[i] >> 22) & 0x01F;
    	str += ' ';
    	str += (M[i] >> 17) & 0x01F;
    	str += ' ';
    	str += (M[i] >> 12) & 0x01F;
    	str += ' ';
    	str += M[i] & 0x0FFF;
    	str += ' | ';
    }
    myWindow.document.write(str);
}
