var sOutput = "";

function printTxtArea(string){
//	var sOutput = output.value;
//	sOutput += string;
//	output.value = sOutput;
//	output.scrollTop = output.scrollHeight;
	
	sOutput += string;
	if(display)
		document.getElementById('output').innerHTML = sOutput;
	output.scrollTop = output.scrollHeight;
}

function printTxtArea2(string){
	var sOutput = memoryOutput.value;
	sOutput += string;
	memoryOutput.value = sOutput;
	memoryOutput.scrollTop = memoryOutput.scrollHeight;
}

function claerTxtArea(){
//	output.value = "";
//	output.scrollTop = output.scrollHeight;
	sOutput = "";
	document.getElementById('output').innerHTML = sOutput;
	output.scrollTop = output.scrollHeight;
}

function claerTxtArea2(){
	memoryOutput.value = "";
	memoryOutput.scrollTop = memoryOutput.scrollHeight;
}

function printMC(string){
	var sOutput = plainTextMC.value;
	sOutput += string;
	plainTextMC.value = sOutput;
	plainTextMC.scrollTop = plainTextMC.scrollHeight;
}

function clearMC(){
	plainTextMC.value = "";
	plainTextMC.scrollTop = plainTextMC.scrollHeight;
}
//simulator of TX processor
//recieve machine code as input
//machine code is generated by assembler in atx.js

var ip;
var AC, Ir, Pc, RetAds, F;
var markLoc = -1;
var runflag = false, display = true, savePc;
var T;
var step;
var end = false;
var M = new Array();
var R = Array(16).fill(0);

function initcpu(){
	var i;
	runflag = true;
	Pc = 0;
	F = 0;
	AC = 0;
	step = 0;
	RetAds = 0;
	for(i = 0; i < 16; i++){
		R[i] = 0;
	}
}

function dumpreg(){
	printTxtArea('<span class="acDisplay">');
	if(markLoc == 18)
		printTxtArea("<b>F:" + F.toString() + "</b>");
	else
		printTxtArea("F:" + F.toString());
	printTxtArea("&nbsp&nbsp");
	if(markLoc == 17)
		printTxtArea("<b>ac:" + AC.toString() + "</b>");
	else
		printTxtArea("ac:" + AC.toString());
	printTxtArea("</span>");
	
	printTxtArea('<span class="regDisplay">');
	var i;
	for(i=0; i<16; i++){
		if(i == markLoc)
			printTxtArea("<b>r" + i.toString() + ":" + R[i].toString() + "</b> ");
		else
			printTxtArea("r" + i.toString() + ":" + R[i].toString() + " ");
	}
	printTxtArea("</span><br>");
}

function updateMemDisplay(){
	var str = "";
    for(var i=0; i<100; i++){
    	if(i%10 == 0 && i != 0)
    		str += "\n";
    	str += "m";
    	str += i.toString();
    	str += " : ";
    	str += M[i] >>> 12;
    	str += ' ';
    	str += M[i] >>> 8 & 0x0000000F;
    	str += ' ';
    	str += M[i] & 0x000000FF;
    	str += ' | ';
    }
    claerTxtArea2();
    printTxtArea2(str);
}

function disassem(op, Ir, ads, d, r1){
	switch(op){
		case 0:	printTxtArea("nop" 	+ "</span><span class='paraDisplay'>"); markLoc = -1; break;
		case 1:	printTxtArea("ld" 	+ "</span><span class='paraDisplay'>" + ads.toString()); markLoc = 17; break;
		case 2:	printTxtArea("st" 	+ "</span><span class='paraDisplay'>" + ads.toString()); markLoc = -1; break;
		case 3: printTxtArea("jmp" 	+ "</span><span class='paraDisplay'>" + ads.toString()); markLoc = 19; break;
		case 4: printTxtArea("jt" 	+ "</span><span class='paraDisplay'>" + ads.toString()); markLoc = 19; break;
		case 5: printTxtArea("jf" 	+ "</span><span class='paraDisplay'>" + ads.toString()); markLoc = 19; break;
		case 6: printTxtArea("call" + "</span><span class='paraDisplay'>" + ads.toString()); markLoc = 19; break;
	
		case 13:
			switch( (Ir & 0x00000F00) >> 8){
				case 0: printTxtArea("crl" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = r1; break;
				case 1: printTxtArea("inc" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = r1; break;
				case 2: printTxtArea("dec" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = r1; break;
			}
			break;
	
		case 14:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0:  printTxtArea("add" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
				case 1:  printTxtArea("sub" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
				case 2:  printTxtArea("and" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
				case 3:  printTxtArea("or" 	+ "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
				case 4:  printTxtArea("xor" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
	
				case 5:   printTxtArea("eq" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 18; break;
				case 6:   printTxtArea("lt" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 18; break;
				case 7:   printTxtArea("le" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 18; break;
				case 8:   printTxtArea("gt" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 18; break;
				case 9:   printTxtArea("ge" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 18; break;
	
				case 10:  printTxtArea("mva" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
				case 11:  printTxtArea("mvr" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = r1; break;
				case 12:  printTxtArea("ldx" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = 17; break;
				case 13:  printTxtArea("stx" + "</span><span class='paraDisplay'>" + "r" + r1.toString()); markLoc = -1; break;
				default:  break;
			}
			break;
	
		case 15:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0: printTxtArea("addi" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 17; break;
				case 1: printTxtArea("subi" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 17; break;
				case 2: printTxtArea("andi" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 17; break;
				case 3: printTxtArea("ori" 	+ "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 17; break;
				case 4: printTxtArea("xori" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 17; break;
	
				case 5: printTxtArea("eqi" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 18; break;
				case 6: printTxtArea("lti" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 18; break;
				case 7: printTxtArea("lei" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 18; break;
				case 8: printTxtArea("gti" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 18; break;
				case 9: printTxtArea("gei" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 18; break;
	
				case 10: printTxtArea("mvi" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = 17; break;
				case 11: printTxtArea("trap" + "</span><span class='paraDisplay'>" + "#" + d.toString()); markLoc = -1; break;
				case 12: printTxtArea("ret" + "</span><span class='paraDisplay'>"); markLoc = -1; break;
				case 13: printTxtArea("not" + "</span><span class='paraDisplay'>"); markLoc = 17; break;
				default: break;
			}
			break;
	
		default:
			 markLoc = -1; break;
	}
}

function trap(){
	runflag = false;
}

function runUntilStop(){
	display = false;
	while(runflag)
		run();
	if(!end){
		display = true;
		printTxtArea("Finished at step " + (step-1).toString());
		//dumpreg();
		end = true;
	}
}

//execute one instruction
function run(){
	
	if(!runflag)
		return;
	
	var op, ads, d, r1;

	savePc = Pc;
	Ir = M[Pc];
	Pc++;
	ads = (Ir & 0x00000FFF);
	d = (Ir & 0x000000FF);
	r1 = (Ir & 0x0000000F);
	op = (Ir & 0x0000F000) >> 12;
	switch(op){
		case 0:	break;
		case 1:	AC = M[ads]; break;
		case 2:	M[ads] = AC; break;
		case 3: Pc = ads; break;
		case 4: if( F != 0 ) Pc = ads; break;
		case 5: if( F == 0 ) Pc = ads; break;
		case 6: RetAds = Pc; Pc = ads; break;

		case 13:
			switch( (Ir & 0x00000F00) >> 8){
				case 0: R[r1] = 0; break;
				case 1: R[r1]++; break;
				case 2: R[r1]--; break;
			}
			break;

		case 14:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0:  AC += R[r1]; break;
				case 1:  AC += R[r1]; break;
				case 2:  AC += R[r1]; break;
				case 3:  AC += R[r1]; break;
				case 4:  AC += R[r1]; break;
	
				case 5:   F = AC == R[r1] ? 1 : 0; break;
				case 6:   F = AC <  R[r1] ? 1 : 0; break;
				case 7:   F = AC <= R[r1] ? 1 : 0; break;
				case 8:   F = AC >  R[r1] ? 1 : 0; break;
				case 9:   F = AC >= R[r1] ? 1 : 0; break;
	
				case 10:  AC = R[r1]; break;
				case 11:  R[r1] = AC; break;
				case 12:  AC = M[(R[15] << 4) + R[r1]]; break;
				case 13:  M[(R[15] << 4) + R[r1]] = AC; break;
				default:  break;
			}
			break;

		case 15:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0: AC += d; break;
				case 1: AC -= d; break;
				case 2: AC &= d; break;
				case 3: AC |= d; break;
				case 4: AC ^= d; break;
	
				case 5:  F = AC == d ? 1 : 0; break;
				case 6:  F = AC <  d ? 1 : 0; break;
				case 7:  F = AC <= d ? 1 : 0; break;
				case 8:  F = AC >  d ? 1 : 0; break;
				case 9:  F = AC >= d ? 1 : 0; break;
	
				case 10: AC = d; break;
				case 11: trap(); break;
				case 12: Pc = RetAds; break;
				case 13: AC = ~AC; break;
				default: break;
			}
			break;

		default:
			break;
	}
	
	printTxtArea("Step " + step.toString());
	printTxtArea("<span class='pcDisplay'>PC " + Pc.toString() + "</span>");
	printTxtArea("<span class='opDisplay'>");
	disassem(op, Ir, ads, d, r1);
	printTxtArea("</span>");
	dumpreg();
		
	step++;
}


function load(){
	
	runflag = true;
	display = true;
	end = false;
	
	initcpu();
	
	var sInput = plainTextMC.value;
	var sOutput = "";

	var lines = sInput.split('\n');

	var cnt, a1, a2, a3;
	
	for(var i = 0; i < lines.length; i++){
	    //code here using lines[i] which will give you each line
		
	    var EoF = false;
	    
	    tokens = lines[i].split(' ');

	    switch(tokens[0]) {
		    case 'a':
		        ip = parseInt(tokens[1]);
		        break;
		       case 'L':
		        a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]);
		        M[ip] = a1<<12 | a2;
		        ip++;
		        break;
		    case 'R':
		    case 'I':
		    	a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]); a3 = parseInt(tokens[3]);
		    	M[ip] = a1<<12 | a2<<8 | a3;
				ip++;
				break;
		    case 'w' :
			    M[ip] = parseInt(tokens[1]);
			    ip++;
				break;
		    case 'e':
			    EoF = true;
			    break;
		    default:
		        break;
		}

	    if(EoF){
		    break;
	    }
	}
	
	claerTxtArea();
	
	printTxtArea("load program, last address " + ip.toString() + "<br>");
	
}


function viewMem() {
    var myWindow = window.open("Memory", "Memory", "width=700,height=500,directories=no,titlebar=no");
    var str = "";
    for(var i=0; i<100; i++){
    	str += "m";
    	str += i.toString();
    	str += " : ";
    	str += M[i] >>> 12;
    	str += ' ';
    	str += M[i] >>> 8 & 0x0000000F;
    	str += ' ';
    	str += M[i] & 0x000000FF;
    	str += ' | ';
    }
    myWindow.document.write(str);
}

//assembler for TX processor
//recieve assembly code as input
//generate machine code for simulator in 

var enableDebug = false;

var sInput, sOutput;
var lines, tokens;
var EoF = false;
var state = 'S';
var lineno = 0, loc = 0, tp = 0, t = 0;
var symnum = 0;
var mem = [];
var symTable = [];
var initsym = [	["NOP", 0], ["LDA", 1], ["STA", 2], 
				["JMP", 3], ["JT", 4], ["JF", 5], ["CALL", 6], 
				["ADD", 10], ["SUB", 11], 
				["AND", 12], ["OR", 13], ["XOR", 14], 
				["EQ", 15], ["LT", 16], ["LE", 17], 
				["GT", 18], ["GE", 19], 
				["ADDI", 20], ["SUBI", 21], 
				["ANDI", 22], ["ORI", 23], ["XORI", 24], 
				["EQI", 25], ["LTI", 26], ["LEI", 27], 
				["GTI", 28], ["GEI", 29], 
				["MVA", 30], ["MVR", 31], ["LDX", 32], ["STX", 33], 
				["MVI", 34], ["TRAP", 35], ["RET", 36], 
				["NOT", 37], ["CLR", 38], ["INC", 39], ["DEC", 40], 
				
				["R0", 0], ["R1", 1], ["R2", 2], ["R3", 3], ["R4", 4], 
				["R5", 5], ["R6", 6], ["R7", 7], ["R8", 8], ["R9", 9], 
				["R10", 10], ["R11", 11], ["R12", 12], ["R13", 13], ["R14", 14], 
				["R15", 15], ["BP", 15]];

function atxMain(){
	
	init();
	initsymbol();

	sInput = plainTextAssembly.value;
	sOutput = "";
	
	print("" + symnum.toString() + " initsymbol");

	lines = sInput.split('\n');
	
	pass1();
	pass2();
	
	clearMC();
	printMC(sOutput);

}

function init(){
	EoF = false;
	state = 'S';
	lineno = 0, loc = 0, tp = 0, t = 0;
	symnum = 0;
	initsym = [	["NOP", 0], ["LDA", 1], ["STA", 2], 
		["JMP", 3], ["JT", 4], ["JF", 5], ["CALL", 6], 
		["ADD", 10], ["SUB", 11], 
		["AND", 12], ["OR", 13], ["XOR", 14], 
		["EQ", 15], ["LT", 16], ["LE", 17], 
		["GT", 18], ["GE", 19], 
		["ADDI", 20], ["SUBI", 21], 
		["ANDI", 22], ["ORI", 23], ["XORI", 24], 
		["EQI", 25], ["LTI", 26], ["LEI", 27], 
		["GTI", 28], ["GEI", 29], 
		["MVA", 30], ["MVR", 31], ["LDX", 32], ["STX", 33], 
		["MVI", 34], ["TRAP", 35], ["RET", 36], 
		["NOT", 37], ["CLR", 38], ["INC", 39], ["DEC", 40], 
		
		["R0", 0], ["R1", 1], ["R2", 2], ["R3", 3], ["R4", 4], 
		["R5", 5], ["R6", 6], ["R7", 7], ["R8", 8], ["R9", 9], 
		["R10", 10], ["R11", 11], ["R12", 12], ["R13", 13], ["R14", 14], 
		["R15", 15], ["BP", 15]];
}

function initsymbol(){
	for(var i = 0; i < initsym.length; i++){
		symTable[initsym[i][0]] = [initsym[i][1], "OP"];
		symnum++;
	}
}

function cmp(string1, string2){
	return string1.toUpperCase() === string2.toUpperCase();
}

// string, int
function store(type, ref){
	mem[tp] = new Array(type, ref, lineno);
	tp++;
	w = ref;
	if(typeof w === "number")
		w = w.toString();
	print("\n--- " + type + " : " + w + " ---");
}

function tok(){
	while(t < tokens.length){
		t++;
		w = tokens[t];
		if(w != '')
			return w;
	}
	return -1;
}

function isNumeric(n) {
	return !isNaN(parseFloat(n)) && isFinite(n);
}

function readR(){
	w = tok();
	if(isNumeric(w))
		store("NUM", parseInt(w));
	else
		store("NUM", symTable[w.toUpperCase()][0])
}

function readM(){
	w = tok();
	if(isNumeric(w))
		store("NUM", parseInt(w));
	else
		store("SYM", w);
}

function readI(){
	w = tok();
	if(w.charAt(0) == '#'){
		w = w.substr(1, w.length - 1);
		if(isNumeric(w))
			store("NUM", parseInt(w));
		else
			store("SYM", w);
	}
	else
		error("expect immediate argument");
	
}

function readcode(){
	var w = tokens[t];
	print("\n opcode : " + w);
	var op = symTable[w.toUpperCase()][0];
	print(" = " + op.toString());
	
	store("OP", op);
	
	switch(op){
		case symTable["LDA"][0]:
		case symTable["STA"][0]:
		case symTable["JMP"][0]:
		case symTable["JT"][0]:
		case symTable["JF"][0]:
		case symTable["CALL"][0]:	readM(); break;

		case symTable["ADD"][0]:
		case symTable["SUB"][0]:
		case symTable["AND"][0]:
		case symTable["OR"][0]:
		case symTable["XOR"][0]:
		case symTable["EQ"][0]:
		case symTable["LT"][0]:
		case symTable["LE"][0]:
		case symTable["GT"][0]:
		case symTable["GE"][0]:
		case symTable["MVA"][0]:
		case symTable["MVR"][0]:
		case symTable["LDX"][0]:
		case symTable["STX"][0]:
		case symTable["CLR"][0]:
		case symTable["INC"][0]:
		case symTable["DEC"][0]:	readR(); break;
		
		case symTable["ADDI"][0]:
		case symTable["SUBI"][0]:
		case symTable["ANDI"][0]:
		case symTable["ORI"][0]:
		case symTable["XORI"][0]:
		case symTable["EQI"][0]:
		case symTable["LTI"][0]:
		case symTable["LEI"][0]:
		case symTable["GTI"][0]:
		case symTable["GEI"][0]:
		case symTable["MVI"][0]:
		case symTable["TRAP"][0]:	readI(); break;
		
		case symTable["RET"][0]:
		case symTable["NOT"][0]:	break;
		
		default: error("undefine op");
	}
	
}

function rdtokval(){
	var w = -1;
	switch(mem[tp][0]){
		case "NUM": w = mem[tp][1]; break;
		case "SYM": w = symTable[mem[tp][1]][0]; break;
		default : error("undefine symbol");
	}
	tp++;
	return w;
}

function prL(op, a1){
	sOutput += "L " + op.toString() + " " + a1.toString() + "\n";
	print(" prL " + op.toString() + " " + a1.toString() + " ");
}

function prR(op, a1){
	sOutput += "R 14 " + op.toString() + " " + a1.toString() + "\n";
	print(" prR " + op.toString() + " " + a1.toString() + " ");
}

function prI(op, a1){
	sOutput += "I 15 " + op.toString() + " " + a1.toString() + "\n";
	print(" prI " + op.toString() + " " + a1.toString() + " ");
}

function gencode(){
	var op, a1;
	
	op = mem[tp][1];
	tp++;
	
	print(" gencode [op=" + op.toString() + "] ");
	
	switch(op){
		case symTable["NOP"][0]: 	prL(0, 0); break;
		case symTable["LDA"][0]:
		case symTable["STA"][0]:
		case symTable["JMP"][0]:
		case symTable["JT"][0]:
		case symTable["JF"][0]:
		case symTable["CALL"][0]:	prL(op, rdtokval()); break;
	
		case symTable["ADD"][0]:
		case symTable["SUB"][0]:
		case symTable["AND"][0]:
		case symTable["OR"][0]:
		case symTable["XOR"][0]:
		case symTable["EQ"][0]:
		case symTable["LT"][0]:
		case symTable["LE"][0]:
		case symTable["GT"][0]:
		case symTable["GE"][0]:		prR(op-10, rdtokval()); break;
			
		case symTable["MVA"][0]:
		case symTable["MVR"][0]:
		case symTable["LDX"][0]:
		case symTable["STX"][0]:	prR(op-20, rdtokval()); break;
		
		case symTable["ADDI"][0]:
		case symTable["SUBI"][0]:
		case symTable["ANDI"][0]:
		case symTable["ORI"][0]:
		case symTable["XORI"][0]:
		case symTable["EQI"][0]:
		case symTable["LTI"][0]:
		case symTable["LEI"][0]:
		case symTable["GTI"][0]:
		case symTable["GEI"][0]:	prI(op-20,rdtokval()); break;
			
		case symTable["MVI"][0]:
		case symTable["TRAP"][0]:	prI(op-24,rdtokval()); break;
		case symTable["RET"][0]:	sOutput += "I 15 12 0" + "\n"; break;
		case symTable["NOT"][0]:	sOutput += "I 15 13 0" + "\n"; break;
		case symTable["CLR"][0]:	sOutput += "R 13 0 " + rdtokval().toString() + "\n"; break;
		case symTable["INC"][0]:	sOutput += "R 13 1 " + rdtokval().toString() + "\n"; break;
		case symTable["DEC"][0]:	sOutput += "R 13 2 " + rdtokval().toString() + "\n"; break;
		
		default: error("undefine op");
	}
}

function print(string1){
	if(enableDebug)
		printTxtArea(string1);
}

function error(string1){
	if(enableDebug)
		printTxtArea("\n" + string1 + " ");
}

function pass1(){

	for(var i = 0; i < lines.length && !EoF; i++){
	    //code here using lines[i] which will give you each line
	    
		print("\nline : " + i.toString());
		
	    tokens = lines[i].split(/\s+/);
	    
	    t = 0;
	    var w = tokens[t];

	    while(true) {
	    	
	    	if(cmp(w, ".END")){
	    		EoF = true;
	    		break;
	    	}
	    	
	    	print(" [" + w + ", " + (t+1).toString() + "/" + tokens.length.toString() + "] ");
	    	if(cmp(w, ".SYMBOL")){
		    	state = 'S';
		    }else if(cmp(w, ".DATA")){
		    	loc = parseInt(tok());
		    	store("DOTD", loc);
		    	state = 'D';
		    }else if(cmp(w, ".CODE")){
		    	loc = parseInt(tok());
		    	store("DOTC", loc);
		    	state = 'C';
		    }else{
		    	 switch(state){
		    	 	case 'S':
		    	 		if(typeof symTable[w] !== 'undefined')
		    	 			print("duplicate symbol");
		    	 		else if(w != ''){
		    	 			symTable[w] = new Array(parseInt(tok()), "SYM");
		    	 			print("new symbol stored : " + w + " = " + symTable[w][0].toString());
		    	 		}
		    	 		break;
		    	 	case 'D':
		    	 		if(isNumeric(w))
		    	 			store("NUM", parseInt(w));
		    	 		else if(w != '')
		    	 			store("SYM", w);
		    	 		loc++;
		    	 		break;
		    	 	case 'C':
		    	 		if(w.charAt(0) == ':'){
		    	 			w = w.substr(1, w.length - 1);
		    	 			if(typeof symTable[w] !== 'undefined')
		    	 				print("duplicate label");
		    	 			else{
		    	 				symTable[w] = new Array(loc, "SYM");
		    	 				print("new label stored : " + w + " = " + loc.toString());
		    	 			}
		    	 		}
		    	 		else if(w != ''){
		    	 			w = w.toUpperCase();
		    	 			
		    	 			if(typeof symTable[w] === 'undefined' 
		    	 				|| symTable[w][1] != "OP")
		    	 				print("undefined op");
		    	 			else{
		    	 				print(" reading code : " + w + " ");
		    	 				readcode();
		    	 			}
		    	 			loc++;
		    	 		}
		    	 			
		    	 
		    	 }
		    }
		    t++;
		    if(t < tokens.length)
		    	w = tokens[t];
		    else
		    	break;
		} // while
	} // for
	store("DOTE", loc);
    
}

function pass2(){
	tp = 0;
	while(mem[tp][0] != "DOTE"){
		switch(mem[tp][0]){
			case "DOTC":
				loc = mem[tp][1];
				sOutput += "a " + loc.toString() + "\n";
				tp++;
				while(mem[tp][0] != "DOTC" && mem[tp][0] != "DOTD" && mem[tp][0] != "DOTE"){
					print("\ngenerating code block (" + tp.toString() + ")");
					gencode();
					loc++;
				}
				break;
			case "DOTD":
				loc = mem[tp][1];
				sOutput += "a " + loc.toString() + "\n";
				tp++;
				while(mem[tp][0] != "DOTC" && mem[tp][0] != "DOTD" && mem[tp][0] != "DOTE"){
					print("\ngenerating data block (" + tp.toString() + ")");
					sOutput += "w " + rdtokval().toString() + "\n";
					loc++;
				}
		}
	}
	sOutput += "e";
	
}