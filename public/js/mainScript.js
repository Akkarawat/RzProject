//simulator of TX processor
//recieve machine code as input
//machine code is generated by assembler in atx.js

var ip;
var AC, Ir, Pc, RetAds, F;
var runflag, savePc;
var T;
var M = new Array();
var R = Array(16).fill(0);

function printTxtArea(string){
	var sOutput = output.value;
	sOutput += string;
	output.value = sOutput;
	output.scrollTop = output.scrollHeight;
}

function initcpu(){
	var i;
	Pc = 0;
	F = 0;
	AC = 0;
	RetAds = 0;
	for(i = 0; i < 16; i++){
		R[i] = 0;
	}
//	printTxtArea("cpu init\n");
}

function dumpreg(){
	printTxtArea(	"F:" + F.toString() + 
					" ac:" + AC.toString() + " ");
	var i;
	for(i=0; i<16; i++){
//	   	if(i%8 == 0){
//	   		printTxtArea("\n");
//	   	}
	   	printTxtArea("r" + i.toString() + ":" + R[i].toString() + " ");
	}
	printTxtArea("\n");
}

function disassem(op, Ir, ads, d, r1){
	switch(op){
		case 0:	printTxtArea("nop"); break;
		case 1:	printTxtArea("ld" + " " + ads.toString()); break;
		case 2:	printTxtArea("st" + " " + ads.toString()); break;
		case 3: printTxtArea("jmp" + " " + ads.toString()); break;
		case 4: printTxtArea("jt" + " " + ads.toString()); break;
		case 5: printTxtArea("jf" + " " + ads.toString()); break;
		case 6: printTxtArea("call" + " " + ads.toString()); break;
	
		case 13:
			switch( (Ir & 0x00000F00) >> 8){
				case 0: printTxtArea("crl" + " r" + r1.toString()); break;
				case 1: printTxtArea("inc" + " r" + r1.toString()); break;
				case 2: printTxtArea("dec" + " r" + r1.toString()); break;
			}
			break;
	
		case 14:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0:  printTxtArea("add" + " r" + r1.toString()); break;
				case 1:  printTxtArea("sub" + " r" + r1.toString()); break;
				case 2:  printTxtArea("and" + " r" + r1.toString()); break;
				case 3:  printTxtArea("or" + " r" + r1.toString()); break;
				case 4:  printTxtArea("xor" + " r" + r1.toString()); break;
	
				case 5:   printTxtArea("eq" + " r" + r1.toString()); break;
				case 6:   printTxtArea("lt" + " r" + r1.toString()); break;
				case 7:   printTxtArea("le" + " r" + r1.toString()); break;
				case 8:   printTxtArea("gt" + " r" + r1.toString()); break;
				case 9:   printTxtArea("ge" + " r" + r1.toString()); break;
	
				case 10:  printTxtArea("mva" + " r" + r1.toString()); break;
				case 11:  printTxtArea("mvr" + " r" + r1.toString()); break;
				case 12:  printTxtArea("ldx" + " r" + r1.toString()); break;
				case 13:  printTxtArea("stx" + " r" + r1.toString()); break;
				default:  break;
			}
			break;
	
		case 15:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0: printTxtArea("addi" + " #" + d.toString()); break;
				case 1: printTxtArea("subi" + " #" + d.toString()); break;
				case 2: printTxtArea("andi" + " #" + d.toString()); break;
				case 3: printTxtArea("ori" + " #" + d.toString()); break;
				case 4: printTxtArea("xori" + " #" + d.toString()); break;
	
				case 5: printTxtArea("eqi" + " #" + d.toString()); break;
				case 6: printTxtArea("lti" + " #" + d.toString()); break;
				case 7: printTxtArea("lei" + " #" + d.toString()); break;
				case 8: printTxtArea("gti" + " #" + d.toString()); break;
				case 9: printTxtArea("gei" + " #" + d.toString()); break;
	
				case 10: printTxtArea("mvi" + " #" + d.toString()); break;
				case 11: printTxtArea("ret"); break;
				case 12: printTxtArea("not"); break;
				case 13: printTxtArea("trap" + " #" + d.toString()); break;
				default: break;
			}
			break;
	
		default:
			break;
	}
}

//execute one instruction
function run(){

	var op, ads, d, r1;

	savePc = Pc;
	Ir = M[Pc];
	Pc++;
	ads = (Ir & 0x00000FFF);
	d = (Ir & 0x000000FF);
	r1 = (Ir & 0x0000000F);
	op = (Ir & 0x0000F000) >> 12;
	switch(op){
		case 0:	break;
		case 1:	AC = M[ads]; break;
		case 2:	M[ads] = AC; break;
		case 3: Pc = ads; break;
		case 4: if( F != 0 ) Pc = ads; break;
		case 5: if( F == 0 ) Pc = ads; break;
		case 6: RetAds = Pc; Pc = ads; break;

		case 13:
			switch( (Ir & 0x00000F00) >> 8){
				case 0: R[r1] = 0; break;
				case 1: R[r1]++; break;
				case 2: R[r1]--; break;
			}
			break;

		case 14:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0:  AC += R[r1]; break;
				case 1:  AC += R[r1]; break;
				case 2:  AC += R[r1]; break;
				case 3:  AC += R[r1]; break;
				case 4:  AC += R[r1]; break;
	
				case 5:   F = AC == R[r1] ? 1 : 0; break;
				case 6:   F = AC <  R[r1] ? 1 : 0; break;
				case 7:   F = AC <= R[r1] ? 1 : 0; break;
				case 8:   F = AC >  R[r1] ? 1 : 0; break;
				case 9:   F = AC >= R[r1] ? 1 : 0; break;
	
				case 10:  AC = R[r1]; break;
				case 11:  R[r1] = AC; break;
				case 12:  AC = M[(R[15] << 4) + R[r1]]; break;
				case 13:  M[(R[15] << 4) + R[r1]] = AC; break;
				default:  break;
			}
			break;

		case 15:
			switch( (Ir & 0x00000F00) >> 8 ){
				case 0: AC += d; break;
				case 1: AC -= d; break;
				case 2: AC &= d; break;
				case 3: AC |= d; break;
				case 4: AC ^= d; break;
	
				case 5:  F = AC == d ? 1 : 0; break;
				case 6:  F = AC <  d ? 1 : 0; break;
				case 7:  F = AC <= d ? 1 : 0; break;
				case 8:  F = AC >  d ? 1 : 0; break;
				case 9:  F = AC >= d ? 1 : 0; break;
	
				case 10: AC = d; break;
				case 11: trap(d); break;
				case 12: Pc = RetAds; break;
				case 13: AC = ~AC; break;
				default: break;
			}
			break;

		default:
			break;
	}
	printTxtArea("PC\t" + Pc.toString() + " ");
	disassem(op, Ir, ads, d, r1);
	printTxtArea("\t\t\t");
	dumpreg();
}


function load(){
	
	var sInput = input.value;
	var sOutput = "";

	var lines = sInput.split('\n');

	var cnt, a1, a2, a3;
	
	for(var i = 0; i < lines.length; i++){
	    //code here using lines[i] which will give you each line
	    
	    var EoF = false;
	    
	    tokens = lines[i].split(' ');

	    switch(tokens[0]) {
		    case 'a':
		        ip = parseInt(tokens[1]);
		        break;
		       case 'L':
		        a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]);
		        M[ip] = a1<<12 | a2;
		        ip++;
		        break;
		    case 'R':
		    case 'I':
		    	a1 = parseInt(tokens[1]); a2 = parseInt(tokens[2]); a3 = parseInt(tokens[3]);
		    	M[ip] = a1<<12 | a2<<8 | a3;
				ip++;
				break;
		    case 'w' :
			    M[ip] = parseInt(tokens[1]);
			    ip++;
				break;
		    case 'e':
			    EoF = true;
			    break;
		    default:
		        break;
		}
	    
//	    sOutput += tokens[0];
//	    sOutput += ' ';
//	    sOutput += tokens[tokens.length - 1];
//	    sOutput += "\n";

	    if(EoF){
		    break;
	    }
	}

//	sOutput += "\nMemory content\n";
//
//	for(var i=0; i<ip; i++){
//		sOutput += i.toString();
//		sOutput += " : ";
//		sOutput += M[i] >>> 12;
//		sOutput += ' ';
//		sOutput += M[i] >>> 8 & 0x0000000F;
//		sOutput += ' ';
//		sOutput += M[i] & 0x000000FF;
//		sOutput += '\n';
//	}
	
	initcpu();
	
	printTxtArea("load program1, last address" + ip.toString() + "\n");

//	output.value = sOutput;
	
}
